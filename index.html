<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>都怪宇宙</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="都怪宇宙">
<meta property="og:type" content="website">
<meta property="og:title" content="都怪宇宙">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="都怪宇宙">
<meta property="og:description" content="都怪宇宙">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="都怪宇宙">
<meta name="twitter:description" content="都怪宇宙">
  
    <link rel="alternative" href="/atom.xml" title="都怪宇宙" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/avatar.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Kiro</a></h1>
		</hgroup>

		
		<p class="header-subtitle">都怪宇宙</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="/#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/AJAX/" style="font-size: 10px;">AJAX</a> <a href="/tags/life/" style="font-size: 10px;">life</a> <a href="/tags/nodejs/" style="font-size: 10px;">nodejs</a> <a href="/tags/web/" style="font-size: 20px;">web</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">或许是因为我们相遇得太早，于是一切无法以美好的方式结束。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Kiro</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/img/avatar.png" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Kiro</h1>
			</hgroup>
			
			<p class="header-subtitle">都怪宇宙</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="/#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-Untitled 3" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/17/Untitled 3/" class="article-date">
  	<time datetime="2016-03-17T05:42:11.000Z" itemprop="datePublished">2016-03-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>CSS框架的迷思</p>
<p>bootstrap<br>semantic-ui<br>foundition</p>
<p>OOCSS<br>面向对象的CSS</p>
<p>SMACSS</p>
<p>Selector performance<br> classes are indexed<br> right to left</p>
<p>ACSS 原子CSS<br>.mr-20{ margin-left:20px }</p>
<p>BEM  block_element_modify</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-自己封装AJAX" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/16/自己封装AJAX/" class="article-date">
  	<time datetime="2016-03-16T07:54:20.000Z" itemprop="datePublished">2016-03-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/16/自己封装AJAX/">自己封装AJAX</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>   一直维护公司前端框架,ajax经常用到，为了提高用户友好程度，每个ajax请求前都加代码太难维护了。所以有了下面的代码</p>
<pre><code>function ajax(opts) {
  var defaults = {
    type: &apos;GET&apos;,
    url: &apos;&apos;,
    data: &apos;&apos;,
    async: true,
    cache: true,
    contentType: &apos;application/x-www-form-urlencoded&apos;,
    success: function () {
    },
    error: function () {
    }
  };
  for (var key in opts) {
    defaults[key] = opts[key];
  }
 if (typeof defaults.data === &apos;object&apos;) {   
    var str = &apos;&apos;;
    for (var key in defaults.data) {
        str += key + &apos;=&apos; + defaults.data[key] + &apos;&amp;&apos;;
    }
    defaults.data = str.substring(0, str.length - 1);
  }
  defaults.type = defaults.type.toUpperCase();
  defaults.cache = defaults.cache ? &apos;&apos; : &apos;&amp;&apos; + new Date().getTime();
  if (defaults.type === &apos;GET&apos; &amp;&amp; (defaults.data || defaults.cache))    defaults.url += &apos;?&apos; + defaults.data + defaults.cache;
  var oXhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);
  oXhr.open(defaults.type, defaults.url, defaults.async);
  if (defaults.type === &apos;GET&apos;)
     oXhr.send(null);
  else {
     oXhr.setRequestHeader(&quot;Content-type&quot;, defaults.contentType);
     oXhr.send(defaults.data);
  }
  oXhr.onreadystatechange = function () {
      if (oXhr.readyState === 4) {
          if (oXhr.status === 200)
              defaults.success.call(oXhr, oXhr.responseText);
          else {
              defaults.error();
          }
      }
  };
  }
</code></pre><p>我必须走出这漫漫黑暗的夜.</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AJAX/">AJAX</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-花店未来的方向" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/12/花店未来的方向/" class="article-date">
  	<time datetime="2016-03-12T05:59:14.000Z" itemprop="datePublished">2016-03-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="u82B1_u5E97_u672A_u6765_u7684_u65B9_u5411"><a href="#u82B1_u5E97_u672A_u6765_u7684_u65B9_u5411" class="headerlink" title="花店未来的方向"></a>花店未来的方向</h1><p>鲜花行业也马上就要进入移动互联网的怀抱了。</p>
<p>从礼品花角度上讲，在移动互联网时代下，很多传统花店都将关门大吉。<br>以下是我的分析（供参考）：<br>在移动互联网的飞速发展下，很多行业都已经迎来变革或者正在变革当中。而鲜花行业由于其行业的特殊性，还处在一个相对传统的状态里。但是，这并不意味着这种状态将会持续下去，而事实上，鲜花行业的变革也已经马上来临，5年之后 很多传统花店都将关门大吉，取而代之的将是更多的线上花店与巨头。<br>有人会说我危言耸听，那下面我们一起来分析一下到底为什么会这样。</p>
<p>##一、中国的鲜花市场是畸形的，传统花店需要被变革。<br>相信有过花店经营经验的人都可以体会到，开实体花店真的不赚钱。</p>
<ol>
<li>店租的巨大成本给经营者带来巨大的压力。</li>
<li>而销量不稳定导致花的损耗颇大。而这些成本肯定会转嫁到消费者身上。</li>
<li>另外，因为这种损耗的压力，花店无法备下多种多样的花材，导致最终的产品形态很单一，视觉效果不好。试想一下，消费者在面对一个土的掉渣而又价值数百的花束的时候，会是什么样的心情。</li>
<li>多半的消费者都还属于被迫消费，而不是出于对于产品本身的喜爱。因此他们不会经常性购买，最终又导致了经营者状态的进一步恶化。</li>
</ol>
<p>这就是存在于国内鲜花市场的恶性循环。经营者和消费者都没有得到好处。最终的利润一部分被损耗掉，一部分被开发商盘剥。</p>
<p>##二、消费者的审美水平逐步在提升，而现有的花店无法满足。<br>未来，消费的主力将由八零后转变为八五后和九零后，这些消费人群从小接触了国外更高审美的影响，对于所购买的产品外观和审美有了更高的追求。而国内现有花店，却很少能够提供这样的匹配性服务。另外，年轻消费者对于线上消费已经有了很强的思维惯性，对于这样的产品更会选择去线上购买更美观更便宜的产品。这点在目前较火的几家线上花店可以窥见一二。</p>
<h2 id="u4E09_u3001_u79FB_u52A8_u4E92_u8054_u7F51_u7AEF_u7684_u793E_u533A_u5316O2O_u670D_u52A1_uFF0C_u5C06_u4F1A_u8695_u98DF_u4F20_u7EDF_u82B1_u5E97_u7684_u86CB_u7CD5"><a href="#u4E09_u3001_u79FB_u52A8_u4E92_u8054_u7F51_u7AEF_u7684_u793E_u533A_u5316O2O_u670D_u52A1_uFF0C_u5C06_u4F1A_u8695_u98DF_u4F20_u7EDF_u82B1_u5E97_u7684_u86CB_u7CD5" class="headerlink" title="三、移动互联网端的社区化O2O服务，将会蚕食传统花店的蛋糕"></a>三、移动互联网端的社区化O2O服务，将会蚕食传统花店的蛋糕</h2><p>目前移动互联网端的社区化进程正在展开，在美国，这种模式已经初见规模。而与此对应，社区化的o2o也将会大范围普及。每一个小区内的人员将会使用APP享受本小区的社区化服务，使得足不出户也能够享受到各种便捷。鲜花也一定会成为其中的一个组成部分。在此之前，更多的传统花店之所以能生存，是因为很多消费者不愿意跑很远去买花，也不愿意去网上购买鲜花等待一天后送达。而社区O2O一旦普及，消费者即可在家通过APP订购，2小时内送达。相比之下，传统花店将会受到巨大的冲击。<br>相信移动互联网对于很多传统的人来说，还只是一个看电影，玩游戏玩微信的途径而已。他们不会认识到移动互联网的精髓到底在哪里，也就更无法认识到为什么移动互联网可以颠覆如此多的行业。而对于鲜花市场，移动互联网能带来什么？为什么可以将现有的鲜花市场给颠覆？</p>
<h2 id="u4E00_u3001_u7EBF_u4E0A_u82B1_u5E97_u5C06_u6781_u5927_u7684_u964D_u4F4E_u7ECF_u8425_u6210_u672C_u3002"><a href="#u4E00_u3001_u7EBF_u4E0A_u82B1_u5E97_u5C06_u6781_u5927_u7684_u964D_u4F4E_u7ECF_u8425_u6210_u672C_u3002" class="headerlink" title="一、线上花店将极大的降低经营成本。"></a>一、线上花店将极大的降低经营成本。</h2><p>线上花店普及，花店经营成本迅速下降。移动互联网给更多的人机会开一家属于自己的花店。</p>
<p>而线上花店相比于普通花店， 在店租一项就获得了巨大的优势。<br>除此之外，理论上，线上花店可以将花材的损耗控制到接近于零。</p>
<p>综合以上两点，线上花店的经营成本将极大的降低。他们也将会为消费者提供更低售价的产品，同时还能保持较高的利润。</p>
<h2 id="u4E8C_u3001_u7EBF_u4E0A_u82B1_u5E97_u53EF_u4EE5_u63D0_u4F9B_u66F4_u597D_u7684_u4F1A_u5458_u670D_u52A1_uFF0C_u6316_u6398_u5BA2_u6237_u7684_u7EC8_u8EAB_u4EF7_u503C_u3002"><a href="#u4E8C_u3001_u7EBF_u4E0A_u82B1_u5E97_u53EF_u4EE5_u63D0_u4F9B_u66F4_u597D_u7684_u4F1A_u5458_u670D_u52A1_uFF0C_u6316_u6398_u5BA2_u6237_u7684_u7EC8_u8EAB_u4EF7_u503C_u3002" class="headerlink" title="二、线上花店可以提供更好的会员服务，挖掘客户的终身价值。"></a>二、线上花店可以提供更好的会员服务，挖掘客户的终身价值。</h2><p>对于花店来说，如果只是一笔一笔成交的话，是非常不划算的，单个客户的获取成本太大。所以，如何将客户收入囊中，增大回头率，挖掘客户的终身价值才是一个更重要的议题。</p>
<p>而随着移动互联网端比较强悍的会员管理系统的应用，线上花店将在会员服务端取得更大的优势。线上花店可以以此为依托，便捷的与更多的会员展开互动，增强粘性，甚至开展个人客户的包年服务，VIP服务。</p>
<h2 id="u4E09_u3001_u7EBF_u4E0A_u82B1_u5E97_u53EF_u4EE5_u63D0_u4F9B_u66F4_u597D_u7684_u4EA7_u54C1_u3002"><a href="#u4E09_u3001_u7EBF_u4E0A_u82B1_u5E97_u53EF_u4EE5_u63D0_u4F9B_u66F4_u597D_u7684_u4EA7_u54C1_u3002" class="headerlink" title="三、线上花店可以提供更好的产品。"></a>三、线上花店可以提供更好的产品。</h2><p>受益于成本的降低，线上花店有更多的精力和资金对产品进行研发。</p>
<p>####而这才是一个花店发展壮大的根本之道。</p>
<p>此条不在赘述，调查一下线上花店的产品水平再看一下线下花店的平均水平，就可以得到结果。<br>说了这么多线上花店的好处，很多人可能会问，这波潮流将会在什么时候开始呢？</p>
<pre><code>在我看来，线上花店的真正爆发时间点，取决于物流。
</code></pre><p>本质上讲，鲜花也属于生鲜，在物流上有很大的劣势。生鲜的冷链物流是目前正在攻克的难题，顺丰与菜鸟网络正在为解决这个问题而努力，因为大家知道，这将是未来一个很大的市场。鲜花也会因此而受益。在不久的将来，一旦生鲜的冷链运输问题解决，鲜花行业就会打破地域的局限。传统的花店最后一个保护屏障就将被坏。80%的传统花店将关门大吉，剩下的只会是一些具有品牌效应的花店与大量的线上花店。<br>朋友曾经国内最大的进口鲜花代理商，现在都已经转战线上了，他们的服务是让各地的花店通过互联网直接就可以下单预定鲜花，保证24小时内送达。各位花店经营者如果想要更好的存活，可以认真思考一下，不要仅仅看到眼下的状态，更要看懂看清未来五年的趋势。</p>
<p>从花艺的角度上来考虑：<br>会有一部分有品位的花店以实体店的形式存活下来，但是需要注意的是，本质上讲，他们已经不是在卖礼品花，而是在售卖一种情调和品位。另外，花店给人带来的良好的氛围也会成为一种重要的吸引力和竞争力。这点其实可以参照咖啡店的现状来考虑。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-前端模块化" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/02/前端模块化/" class="article-date">
  	<time datetime="2016-03-02T02:04:16.000Z" itemprop="datePublished">2016-03-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/02/前端模块化/">前端模块化</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>  在JavaScript发展初期就是为了实现简单的页面交互逻辑，寥寥数语即可；如今CPU、浏览器性能得到了极大的提升，很多页面逻辑迁移到了客户端（表单验证等），随着web2.0时代的到来，Ajax技术得到广泛应用，jQuery等前端库层出不穷，前端代码日益膨胀</p>
<p>  这时候JavaScript作为嵌入式的脚本语言的定位动摇了，JavaScript却没有为组织代码提供任何明显帮助，甚至没有类的概念，更不用说模块（module）了，JavaScript极其简单的代码组织规范不足以驾驭如此庞大规模的代码</p>
<p>##模块</p>
<p>既然JavaScript不能handle如此大规模的代码，我们可以借鉴一下其它语言是怎么处理大规模程序设计的，在Java中有一个重要带概念——package，逻辑上相关的代码组织到同一个包内，包内是一个相对独立的王国，不用担心命名冲突什么的，那么外部如果使用呢？直接import对应的package即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br></pre></td></tr></table></figure>
<p>遗憾的是JavaScript在设计时定位原因，没有提供类似的功能，开发者需要模拟出类似的功能，来隔离、组织复杂的JavaScript代码，我们称为模块化。</p>
<p>一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。模块开发需要遵循一定的规范，各行其是就都乱套了</p>
<p>规范形成的过程是痛苦的，前端的先驱在刀耕火种、茹毛饮血的阶段开始，发展到现在初具规模，简单了解一下这段不凡的历程</p>
<p>##函数封装<br>我们在讲函数的时候提到，函数一个功能就是实现特定逻辑的一组语句打包，而且JavaScript的作用域就是基于函数的，所以把函数作为模块化的第一步是很自然的事情，在一个文件里面编写几个相关函数就是最开始的模块了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function fn1()&#123;&#10;    statement&#10;&#125;&#10;&#10;function fn2()&#123;&#10;    statement&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这样在需要的以后夹在函数所在文件，调用函数就可以了</p>
<p>这种做法的缺点很明显：污染了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间没什么关系。</p>
<h2 id="u5BF9_u8C61"><a href="#u5BF9_u8C61" class="headerlink" title="对象"></a>对象</h2><p>为了解决上面问题，对象的写法应运而生，可以把所有的模块成员封装在一个对象中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var myModule = &#123;&#10;    var1: 1,&#10;&#10;    var2: 2,&#10;&#10;    fn1: function()&#123;&#10;&#10;    &#125;,&#10;&#10;    fn2: function()&#123;&#10;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们在希望调用模块的时候引用对应文件，然后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myModule.fn2();</span><br></pre></td></tr></table></figure>
<p>这样避免了变量污染，只要保证模块名唯一即可，同时同一模块内的成员也有了关系</p>
<p>看似不错的解决方案，但是也有缺陷，外部可以随意修改内部成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myModel.var1 = 100;</span><br></pre></td></tr></table></figure>
<p>这样就会产生意外的安全问题</p>
<p>立即执行函数<br>可以通过立即执行函数，来达到隐藏细节的目的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var myModule = (function()&#123;&#10;    var var1 = 1;&#10;    var var2 = 2;&#10;&#10;    function fn1()&#123;&#10;&#10;    &#125;&#10;&#10;    function fn2()&#123;&#10;&#10;    &#125;&#10;&#10;    return &#123;&#10;        fn1: fn1,&#10;        fn2: fn2&#10;    &#125;;&#10;&#125;)();</span><br></pre></td></tr></table></figure>
<p>这样在模块外部无法修改我们没有暴露出来的变量、函数</p>
<p>上述做法就是我们模块化的基础，目前，通行的JavaScript模块规范主要有两种：CommonJS和AMD</p>
<p>CommonJS<br>我们先从CommonJS谈起，因为在网页端没有模块化编程只是页面JavaScript逻辑复杂，但也可以工作下去，在服务器端却一定要有模块，所以虽然JavaScript在web端发展这么多年，第一个流行的模块化规范却由服务器端的JavaScript应用带来，CommonJS规范是由NodeJS发扬光大，这标志着JavaScript模块化编程正式登上舞台。</p>
<p>定义模块<br>根据CommonJS规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性</p>
<p>模块输出：<br>模块只有一个出口，module.exports对象，我们需要把模块希望输出的内容放入该对象</p>
<p>加载模块：<br>加载模块使用require方法，该方法读取一个文件并执行，返回文件内部的module.exports对象</p>
<p>看个例子</p>
<p>//模块定义 myModel.js</p>
<p>var name = ‘Byron’;</p>
<p>function printName(){<br>    console.log(name);<br>}</p>
<p>function printFullName(firstName){<br>    console.log(firstName + name);<br>}</p>
<p>module.exports = {<br>    printName: printName,<br>    printFullName: printFullName<br>}</p>
<p>//加载模块</p>
<p>var nameModule = require(‘./myModel.js’);</p>
<p>nameModule.printName();<br>不同的实现对require时的路径有不同要求，一般情况可以省略js拓展名，可以使用相对路径，也可以使用绝对路径，甚至可以省略路径直接使用模块名（前提是该模块是系统内置模块）</p>
<p>尴尬的浏览器<br>仔细看上面的代码，会发现require是同步的。模块系统需要同步读取模块文件内容，并编译执行以得到模块接口。</p>
<p>这在服务器端实现很简单，也很自然，然而， 想在浏览器端实现问题却很多。</p>
<p>浏览器端，加载JavaScript最佳、最容易的方式是在document中插入script 标签。但脚本标签天生异步，传统CommonJS模块在浏览器环境中无法正常加载。</p>
<p>解决思路之一是，开发一个服务器端组件，对模块代码作静态分析，将模块与它的依赖列表一起返回给浏览器端。 这很好使，但需要服务器安装额外的组件，并因此要调整一系列底层架构。</p>
<p>另一种解决思路是，用一套标准模板来封装模块定义，但是对于模块应该怎么定义和怎么加载，又产生的分歧：</p>
<p>AMD<br>AMD 即Asynchronous Module Definition，中文名是异步模块定义的意思。它是一个在浏览器端模块化开发的规范</p>
<p>由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎RequireJS，实际上AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出</p>
<p>requireJS主要解决两个问题</p>
<p>多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器<br>js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长<br>看一个使用requireJS的例子</p>
<p>// 定义模块 myModule.js<br>define([‘dependency’], function(){<br>    var name = ‘Byron’;<br>    function printName(){<br>        console.log(name);<br>    }</p>
<pre><code>return {
    printName: printName
};
</code></pre><p>});</p>
<p>// 加载模块<br>require([‘myModule’], function (my){<br>　 my.printName();<br>});</p>
<p>语法<br>requireJS定义了一个函数 define，它是全局变量，用来定义模块</p>
<p>define(id?, dependencies?, factory);<br>id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名）<br>dependencies：是一个当前模块依赖的模块名称数组<br>factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值<br>在页面上使用require函数加载模块</p>
<p>require([dependencies], function(){});<br>require()函数接受两个参数</p>
<p>第一个参数是一个数组，表示所依赖的模块<br>第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块<br>require()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。</p>
<p>CMD<br>CMD 即Common Module Definition通用模块定义，CMD规范是国内发展出来的，就像AMD有个requireJS，CMD有个浏览器的实现SeaJS，SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同</p>
<p>语法<br>Sea.js 推崇一个模块一个文件，遵循统一的写法</p>
<p>define<br>define(id?, deps?, factory)<br>因为CMD推崇</p>
<p>一个文件一个模块，所以经常就用文件名作为模块id<br>CMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写<br>factory有三个参数</p>
<p>function(require, exports, module)<br>require<br>require 是 factory 函数的第一个参数</p>
<p>require(id)<br>require 是一个方法，接受 模块标识 作为唯一参数，用来获取其他模块提供的接口</p>
<p>exports<br>exports 是一个对象，用来向外提供模块接口</p>
<p>module<br>module 是一个对象，上面存储了与当前模块相关联的一些属性和方法</p>
<p>demo<br>// 定义模块  myModule.js<br>define(function(require, exports, module) {<br>  var $ = require(‘jquery.js’)<br>  $(‘div’).addClass(‘active’);<br>});</p>
<p>// 加载模块<br>seajs.use([‘myModule.js’], function(my){</p>
<p>});<br>AMD与CMD区别<br>关于这两个的区别网上可以搜出一堆文章，简单总结一下</p>
<p>最明显的区别就是在模块定义时对依赖的处理不同</p>
<p>AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块<br>CMD推崇就近依赖，只有在用到某个模块的时候再去require<br>这种区别各有优劣，只是语法上的差距，而且requireJS和SeaJS都支持对方的写法</p>
<p>AMD和CMD最大的区别是对依赖模块的执行时机处理不同，注意不是加载的时机或者方式不同</p>
<p>很多人说requireJS是异步加载模块，SeaJS是同步加载模块，这么理解实际上是不准确的，其实加载模块都是异步的，只不过AMD依赖前置，js可以方便知道依赖模块是谁，立即加载，而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略</p>
<p>为什么我们说两个的区别是依赖模块执行时机不同，为什么很多人认为ADM是异步的，CMD是同步的（除了名字的原因。。。）</p>
<p>同样都是异步加载模块，AMD在加载模块完成后就会执行改模块，所有模块都加载执行完后会进入require的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行</p>
<p>CMD加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的</p>
<p>这也是很多人说AMD用户体验好，因为没有延迟，依赖模块提前执行了，CMD性能好，因为只有用户需要的时候才执行的原因</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web/">web</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-更多的人死于心碎" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/02/02/更多的人死于心碎/" class="article-date">
  	<time datetime="2016-02-02T03:42:40.000Z" itemprop="datePublished">2016-02-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/02/更多的人死于心碎/">更多的人死于心碎</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>2015年12月28日中午，Debian操作系统的创始人Ian Murdock，在推特上发布了一条简短的消息。</p>
<img src="/2016/02/02/更多的人死于心碎/bg2016011701.jpg" alt="bg2016011701.jpg" title="">
<blockquote>
<p>我将在今晚自杀，请不要打扰，我要抓紧时间说一些事情，不让它们跟我一起走<br>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/life/">life</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/02/02/更多的人死于心碎/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy;Copyright 2016 Kiro
    	</div>
      	<div class="footer-right">
      		<a href="http://kiroli.cn/" target="_blank">Kiro</a> by Kiro
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>